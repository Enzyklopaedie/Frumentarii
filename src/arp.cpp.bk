// https://beej.us/guide/bgnet/html/index-wide.html

#include "arp.h"
#include <string>
#include <ifaddrs.h>
#include <cstring>
#include <sys/ioctl.h>
#include <arpa/inet.h>
#include <net/if.h>
#include <unistd.h>
#include <netinet/ether.h>
#include <stdexcept>
#include <sys/socket.h>
#include <netpacket/packet.h>
#include <iostream>


std::string getDefaultInterface(){
    struct ifaddrs *ifaddr, *ifa;
    std::string defaultInterface;

    if (getifaddrs(&ifaddr) == -1) {
        perror("getifaddrs");
        return defaultInterface;
    }

    // Iterate through the linked list of network interfaces
    for (ifa = ifaddr; ifa != nullptr; ifa = ifa->ifa_next) {
        if (ifa->ifa_addr == nullptr) continue;
        // Check for an IPv4 address to identify an active interface
        if (ifa->ifa_addr->sa_family == AF_INET) { // IPv4-Address
            defaultInterface = ifa->ifa_name;
            break; // First avilable Interface with IP selected
        }
    }

    freeifaddrs(ifaddr);
    return defaultInterface;
};

std::array<uint8_t, 6> getMacAddress(const char* ifname){
    struct ifreq ifr;
    int sock = socket(AF_INET, SOCK_DGRAM, 0);                  // SOCK_DGRAM => Datagram Socket, connectionless socket -> UDP
    strncpy(ifr.ifr_name, ifname, IFNAMSIZ);
    // Use an ioctl call to get the hardware address
    ioctl(sock, SIOCGIFHWADDR, &ifr);
    close(sock);

    return std::array<uint8_t, 6>{
        static_cast<uint8_t>(ifr.ifr_hwaddr.sa_data[0]),
        static_cast<uint8_t>(ifr.ifr_hwaddr.sa_data[1]),
        static_cast<uint8_t>(ifr.ifr_hwaddr.sa_data[2]),
        static_cast<uint8_t>(ifr.ifr_hwaddr.sa_data[3]),
        static_cast<uint8_t>(ifr.ifr_hwaddr.sa_data[4]),
        static_cast<uint8_t>(ifr.ifr_hwaddr.sa_data[5]),
    };
}

std::array<uint8_t, 4> getIpAddress(const char* ifname) {
    struct ifaddrs *ifaddr, *ifa;
    std::string ipAddress;

    if (getifaddrs(&ifaddr) == -1) {
        perror("getifaddrs");
        throw std::runtime_error("Failed to get network interfaces");
    }

    for (ifa = ifaddr; ifa != nullptr; ifa = ifa->ifa_next) {
        if (ifa->ifa_addr == nullptr) continue;

        // Check if this is the interface we want and if it's IPv4
        if (strcmp(ifa->ifa_name, ifname) == 0 && ifa->ifa_addr->sa_family == AF_INET) {
            void* addr = &((struct sockaddr_in*)ifa->ifa_addr)->sin_addr;
            char ip[INET_ADDRSTRLEN];
            inet_ntop(AF_INET, addr, ip, INET_ADDRSTRLEN);
            ipAddress = ip;
            break;
        }
    }

    freeifaddrs(ifaddr);

    if (ipAddress.empty()) {
        throw std::runtime_error("No IPv4 address found for interface");
    }

    std::array<uint8_t, 4>resultIpAddress = {};

    // Convert IP-String ("192.168.1.1") to a 4-byte array
    struct in_addr ipAddr;
    if (inet_pton(AF_INET, ipAddress.c_str(), &ipAddr) != 1) {
        throw std::runtime_error("Failed to convert IP address");
    }

    // Copy 4 Bytes of IP-Adresse to Result-Array
    const uint8_t* ipBytes = reinterpret_cast<const uint8_t*>(&ipAddr.s_addr);
    for (int i = 0; i < 4; i++) {
        resultIpAddress[i] = ipBytes[i];
    }

    return resultIpAddress;
}


std::array<uint8_t, 60> buildARPRequest(
    const uint8_t senderMAC[6], 
    const uint8_t senderIP[4], 
    const uint8_t targetIP[4])
{
    std::array<uint8_t, 60> packet{}; // Initialize an Ethernet frame (minimum size 60 bytes)

    // --- Ethernet Header ---
    
    // Destination MAC: Broadcast (FF:FF:FF:FF:FF:FF) to reach all devices on the local network.
    for (int i = 0; i < 6; i++){
        packet[i] = 0xFF;
    }

    // Source MAC: Our own hardware address.
    for (int i = 0; i < 6; i++){
        packet[6+i] = senderMAC[i];
    }

    // Ethertype: 0x0806 signifies an ARP packet.
    packet[12] = 0x08;
    packet[13] = 0x06;


    // --- ARP Payload ---
    // Hardware Type: 1 for Ethernet.
    packet[14] = 0x00;
    packet[15] = 0x01;

    // Protocol Type: 0x0800 for IPv4.
    packet[16] = 0x08;
    packet[17] = 0x00;

    // Hardware Address Length: 6 bytes for MAC.
    packet[18] = 6;

    // Protocol Address Length: 4 bytes for IPv4.
    packet[19] = 4;

    // Operation: 1 for ARP Request.
    packet[20] = 0x00;
    packet[21] = 0x01;

    // Sender MAC Address
    for (int i = 0; i < 6; i++){
        packet[22 + i] = senderMAC[i];
    }

    // Sender IP Address
    for (int i = 0; i < 4; i++){
        packet[28 + i] = senderIP[i];
    }

    // Target MAC Address: All zeros because we don't know it yet; this is what we're asking for.
    for (int i = 0; i < 6; i++){
        packet[32 + i] = 0x00;
    }

    // Target IP Address
    for (int i = 0; i < 4; i++){
        packet[38 + i] = targetIP[i];
    }

    // Padding to meet the minimum Ethernet frame size of 60 bytes.
    for (int i = 0; i < 18; i++){
        packet[42 + i] = 0x00;
    }

    return packet;
}

std::string actuallySendingTheARPRequest(){
    // 1. Get local network information
    std::string ifname = getDefaultInterface();
    if (ifname.empty()){
        std::__throw_runtime_error("No network interface found!");
    }
    std::array<uint8_t, 6> ownMac = getMacAddress(ifname.c_str());
    std::array<uint8_t, 4> ownIp = getIpAddress(ifname.c_str());

    // Assuming a simple /24 subnet (e.g., 192.168.1.x)
    std::array<uint8_t, 4> targetIp = ownIp;

    // 2. Open a raw socket to send custom Ethernet frames
    int rawSocket = socket(AF_PACKET, SOCK_RAW, htons(ETH_P_ARP));      // AF_PACKET: Linux specific protocol to send without OS TCP/IP Stack
                                                                        // SOCK_RAW: Raw socket, no protocol header is added
                                                                        // htons(): Converting byte order from CPU byte-order to Network Byte Order (Big Endian)
                                                                        // 
    if (rawSocket == -1) {
        perror("socket");
        return "Failed to create socket";
    }

    // 3. Bind the socket to the specific network interface
    struct ifreq ifr;
    strncpy(ifr.ifr_name, ifname.c_str(), IFNAMSIZ);
    if (ioctl(rawSocket, SIOCGIFINDEX, &ifr) == -1) {
        perror("ioctl");
        close(rawSocket);
        return "Failed to get interface index";
    }
    
    struct sockaddr_ll addr = {};
    addr.sll_family = AF_PACKET;
    addr.sll_protocol = htons(ETH_P_ARP);
    addr.sll_ifindex = ifr.ifr_ifindex;
    addr.sll_halen = ETHER_ADDR_LEN;
    memset(addr.sll_addr, 0xff, ETHER_ADDR_LEN); // Set destination MAC to broadcast

    // 4. Loop through all possible IPs in the subnet and send an ARP request
    for (int i = 0; i < 256; i++){
        targetIp[3] = i; // Iterate through the last octet (e.g., 192.168.1.0 to 192.168.1.255)
        
        auto packet = buildARPRequest(ownMac.data(), ownIp.data(), targetIp.data());

        if (sendto(rawSocket, packet.data(), packet.size(), 0, 
            (struct sockaddr*)&addr, sizeof(addr)) == -1) {
            perror("sendto");
        }
    }
    
    close(rawSocket);

    // TODO: Implement listening for and parsing ARP replies to build a list of active hosts.

    return "Super";
}